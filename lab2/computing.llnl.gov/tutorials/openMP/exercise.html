<HTML>
<HEAD>
<TITLE> OpenMP Exercise </TITLE>

<SCRIPT LANGUAGE="JavaScript" SRC="../tutorials.js"></SCRIPT>
<LINK REL=StyleSheet HREF="../tutorials.css" TYPE="text/css">

</HEAD>

<BODY BGCOLOR=#FFFFFF>
<BASEFONT SIZE=3>            <!-- default font size -->

<A NAME=top> </A>
<TABLE CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD BGCOLOR=#3F5098>
  <TABLE CELLPADDING=0 CELLSPACING=0 WIDTH=900>
  <TR><TD BACKGROUND=../images/bg1.gif>
  <SCRIPT LANGUAGE="JavaScript">addNavigation()</SCRIPT>
  <P><BR>
  <H1>OpenMP Exercise</H1>
  <P>
  </TD></TR></TABLE>
</TD></TR></TABLE>

<OL>
<P>
<B><LI>Login to the workshop machine</B>
<P>
    Workshops differ in how this is done.  The instructor will go over this     
    beforehand.

<P>
<B><LI>Copy the example files</B>
<OL>
<P>
<LI>In your home directory, create a subdirectory for the example codes
    and then <TT>cd</TT> to it.
<P><PRE><B>mkdir openMP
cd  openMP </B></PRE>
<P>
<LI>Then, copy either the Fortran or the C version of the parallel OpenMP
    exercise files to your openMP subdirectory:
<P>
<TABLE BORDER=0 CELLPADDING=5>
<TR VALIGN=top>
<TD BGCOLOR=EEEEEE><B>C: </TD>
<TD><PRE><B>cp  /usr/global/docs/training/blaise/openMP/C/*  ~/openMP</B>
</PRE></TD>
</TR><TR VALIGN=top>
<TD BGCOLOR=EEEEEE><B>Fortran: </TD>
<TD><PRE><B>cp  /usr/global/docs/training/blaise/openMP/Fortran/*  ~/openMP</B>
</PRE></TD>
</TR></TABLE>
</OL>

<P>
<B><LI> List the contents of your openMP subdirectory</B>
<P>
You should notice the following files:
<P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=90%>
<TR VALIGN=top>
<TH>C Files</TH>
<TH>Fortran Files</TH>
<TH>Description</TH>

</TR><TR VALIGN=top>
<TD><TT><A HREF=samples/C/omp_hello.c TARGET=WE1>  
omp_hello.c</A></TD>
<TD><TT><A HREF=samples/Fortran/omp_hello.f TARGET=WE2>  
omp_hello.f</A></TD>
<TD>Hello world</TD>

</TR><TR VALIGN=top>
<TD><TT><A HREF=samples/C/omp_workshare1.c TARGET=WE3>  
omp_workshare1.c</A></TD>
<TD><TT><A HREF=samples/Fortran/omp_workshare1.f TARGET=WE4>  
omp_workshare1.f</A></TD>
<TD>Loop work-sharing</TD>

</TR><TR VALIGN=top>
<TD><TT><A HREF=samples/C/omp_workshare2.c TARGET=WE5>  
omp_workshare2.c</A></TD>
<TD><TT><A HREF=samples/Fortran/omp_workshare2.f TARGET=WE6>  
omp_workshare2.f</A></TD>
<TD>Sections work-sharing</TD>

</TR><TR VALIGN=top>
<TD><TT><A HREF=samples/C/omp_reduction.c TARGET=WE7>
omp_reduction.c</A></TD>
<TD><TT><A HREF=samples/Fortran/omp_reduction.f TARGET=WE8>
omp_reduction.f</A></TD>
<TD>Combined parallel loop reduction</TD>

</TR><TR VALIGN=top>
<TD><TT><A HREF=samples/C/omp_orphan.c TARGET=WE9>
omp_orphan.c</A></TD>
<TD><TT><A HREF=samples/Fortran/omp_orphan.f TARGET=WE10>
omp_orphan.f</A></TD>
<TD>Orphaned parallel loop reduction</TD>

</TR><TR VALIGN=top>
<TD><TT><A HREF=samples/C/omp_mm.c TARGET=WE11>
omp_mm.c</A></TD>
<TD><TT><A HREF=samples/Fortran/omp_mm.f TARGET=WE12>
omp_mm.f</A></TD>
<TD>Matrix multiply</TD>

</TR><TR VALIGN=top>
<TD><TT><A HREF=samples/C/omp_getEnvInfo.c TARGET=W11>
omp_getEnvInfo.c</A></TD>
<TD><TT><A HREF=samples/Fortran/omp_getEnvInfo.f TARGET=W12>
omp_getEnvInfo.f</A></TD>
<TD>Get and print environment information</TD>

</TR><TR VALIGN=top>
<TD><TT><A HREF=samples/C/omp_bug1.c TARGET=WE13>
omp_bug1.c</A>
<BR><TT><A HREF=samples/C/omp_bug1fix.c TARGET=WE14>
omp_bug1fix.c</A>
<BR><TT><A HREF=samples/C/omp_bug2.c TARGET=WE15>
omp_bug2.c</A>
<BR><TT><A HREF=samples/C/omp_bug3.c TARGET=WE16>
omp_bug3.c</A>
<BR><TT><A HREF=samples/C/omp_bug4.c TARGET=WE17>
omp_bug4.c</A>
<BR><TT><A HREF=samples/C/omp_bug4fix TARGET=WE18>
omp_bug4fix</A>
<BR><TT><A HREF=samples/C/omp_bug5.c TARGET=WE19>
omp_bug5.c</A>
<BR><TT><A HREF=samples/C/omp_bug5fix.c TARGET=WE20>
omp_bug5fix.c</A>
<BR><TT><A HREF=samples/C/omp_bug6.c TARGET=WE21>
omp_bug6.c</A>
</TD>
<TD><TT><A HREF=samples/Fortran/omp_bug1.f TARGET=WE22>
omp_bug1.f</A>
<BR><TT><A HREF=samples/Fortran/omp_bug1fix.f TARGET=WE23>
omp_bug1fix.f</A>
<BR><TT><A HREF=samples/Fortran/omp_bug2.f TARGET=WE24>
omp_bug2.f</A>
<BR><TT><A HREF=samples/Fortran/omp_bug3.f TARGET=WE25>
omp_bug3.f</A>
<BR><TT><A HREF=samples/Fortran/omp_bug4.f TARGET=WE26>
omp_bug4.f</A>
<BR><TT><A HREF=samples/Fortran/omp_bug4fix TARGET=WE27>
omp_bug4fix</A>
<BR><TT><A HREF=samples/Fortran/omp_bug5.f TARGET=WE28>
omp_bug5.f</A>
<BR><TT><A HREF=samples/Fortran/omp_bug5fix.f TARGET=WE29>
omp_bug5fix.f</A>
<BR><TT><A HREF=samples/Fortran/omp_bug6.f TARGET=WE30>
omp_bug6.f</A>
</TD>
<TD>Programs with bugs</TD>
</TR></TABLE>

<P>
<B><I>Note:</I></B> Most of these are simple example files.  Their primary
purpose is to demonstrate the basics of how to parallelize a code with OpenMP.  Most execute in less than a second.

<P>
<B><LI>Review / compile / run the Hello World example code</B> 
<P>  
<OL>
<LI>Take a moment to examine the source code and note how OpenMP directives 
    and library routines are being used.
<P>  
<LI>Depending upon your language and compiler preference, use one of the following commands to compile the code: 
<P>
<TABLE BORDER=0 CELLPADDING=5>
<TR VALIGN=top>
<TD BGCOLOR=EEEEEE><B>C:</B></B>
<TD><PRE><B>icc -openmp omp_hello.c -o hello
pathcc -mp omp_hello.c -o hello
pgcc -mp omp_hello.c -o hello
gcc -fopenmp omp_hello.c -o hello</B></PRE></TD>
</TR><TR VALIGN=top>
<TD BGCOLOR=EEEEEE><B>Fortran:</B></TD>
<TD><PRE><B>ifort -openmp omp_hello.f -o hello
pathf90 -mp omp_hello.f -o hello
pgf90 -mp omp_hello.f -o hello
gfortran -fopenmp omp_hello.f -o hello</B></PRE></TD>
</TR></TABLE>
<P>
<LI>To run the code, simply type the command <TT><B>hello</B></TT> and the 
    program should run.
<BR>How many threads were created?
<BR>Why?
<BR><B>Note:</B> The PGI compilers use a different default number of threads
than the other compilers. The next step shows how to alter this.
</OL>

<P>
<B><LI> Vary the number of threads and re-run Hello World</B>
<P>
<OL>
<LI>Set the number of threads to use by means of the OMP_NUM_THREADS 
    environment variable.  
<PRE><B>setenv OMP_NUM_THREADS 4</B></PRE>
<LI>Re-run the example code and notice the output.
<PRE><B>hello</B></PRE>
<LI>Your output should look similar to below.  The actual order of output 
    strings may vary.
<P>
<TABLE BORDER=1 CELLPADDING=5 CELLSPACING=0 WIDTH=90%>
<TR><TD><PRE>Hello World from thread = 0 
Number of threads = 4
Hello World from thread = 3
Hello World from thread = 1
Hello World from thread = 2</PRE></TD>
</TR></TABLE>
</OL>
<P>

<B><LI> Review / Compile / Run the workshare1 example code</B>
<P>
This example demonstrates use of the OpenMP loop work-sharing construct.
Notice that it specifies dynamic scheduling of threads and assigns a 
specific number of iterations to be done by each thread.
    <OL>
    <P>
    <LI>After reviewing the source code, use your preferred compiler to compile
    and run the executable. (We're assuming your OMP_NUM_THREADS variable
    is still set to 4). For example:
    <P>
    <TABLE BORDER=0 CELLPADDING=5>
    <TR VALIGN=top>
    <TD BGCOLOR=EEEEEE><B>C:</B></TD>
    <TD><TT><B>icc -openmp omp_workshare1.c -o workshare1
    <BR>workshare1 | sort</B></TT></TD>
    <TR VALIGN=top>
    <TD BGCOLOR=EEEEEE><B>Fortran:</B></TD>
    <TD><TT><B>ifort -openmp omp_workshare1.f -o workshare1
    <BR>workshare1 | sort</B></TT></TD>
    </TR></TABLE>
    <P>
    <LI>Review the output. Note that it is piped through the sort utility.  
        This will make it easier to view how loop iterations were actually 
        scheduled across the team of threads.
    <P>
    <LI>Run the program a couple more times and review the output. 
        What do you see? Typically, dynamic scheduling is not deterministic.
        Everytime you run the program, different threads can run different
        chunks of work. It is even possible that a thread might not do any
        work because another thread is quicker and takes more work. In fact,
        it might be possible for one thread to do all of the work.
    <P>
    <LI>Edit the workshare1 source file and change the dynamic scheduling to
        static scheduling.
    <P>
    <LI>Recompile and run the modified program. Notice the difference in 
        output compared to dynamic scheduling. Specifically, notice that
        thread 0 gets the first chunk, thread 1 the second chunk, and so on.
    <P>
    <LI>Run the program a couple more times. Does the output change?
        With static scheduling, the allocation of work is deterministic and
        should not change between runs, and every thread gets work to do.
    <P>
    <LI>Reflect on possible performance differences between dynamic and
        static scheduling. 
    </OL>

<P>
<B><LI> Review / Compile / Run the workshare2 example code</B>
<P>
This example demonstrates use of the OpenMP SECTIONS work-sharing construct
Note how the PARALLEL region is divided into separate sections, each of 
which will be executed by one thread.   
<P>
<OL>
<LI>As before, compile and execute the program after reviewing it. For
    example:
<P>
<TABLE BORDER=0 CELLPADDING=5>
<TR VALIGN=top>
<TD BGCOLOR=EEEEEE><B>C:</TD>
<TD><TT><B>icc -openmp omp_workshare2.c -o workshare2
<BR>workshare2</B></TT></TD>
</TR><TR VALIGN=top>
<TD BGCOLOR=EEEEEE><B>Fortran:</TD>
<TD><TT><B>ifort -openmp omp_workshare2.f -o workshare2
<BR>workshare2</B></TT></TD>
</TR></TABLE>
<P>
<LI>Run the program several times and observe any differences in output.  
Because there are only two sections, you should notice that some threads do 
not do any work.  You may/may not notice that the threads doing work can vary.
For example, the first time thread 0 and thread 1 may do the work, and the 
next time it may be thread 0 and thread 3.  It is even possible for one thread 
to do all of the work.  Which thread does work is non-deterministic in this 
case.
</OL>

<P>
<B><LI> Review / Compile / Run the orphan example code</B>
<P>
This example computes a dot product in parallel, however it differs from 
previous examples because the parallel loop construct is orphaned - it is
contained in a subroutine outside the lexical extent of the main program's
parallel region.
<P>
<OL>
<LI>After reviewing the source code, compile and run the program. For example:
<P>
<TABLE BORDER=0 CELLPADDING=5>
<TR VALIGN=top>
<TD BGCOLOR=EEEEEE><B>C:</B></TD>
<TD><TT><B>icc -openmp omp_orphan.c -o orphan
<BR>orphan | sort</B></TT></TD>
</TR><TR VALIGN=top>
<TD BGCOLOR=EEEEEE><B>Fortran:</B></TD>
<TD><TT><B>ifort -openmp omp_orphan.f -o orphan
<BR>orphan | sort</B></TT></TD>
</TR></TABLE>
<P>
<LI>Note the result...and the fact that this example will come back to haunt 
    as <TT>omp_bug6</TT> later.
</OL>

<P>
<B><LI> Review / Compile / Run the matrix multiply example code</B>
<P>
This example performs a matrix multiple by distributing the iterations
of the operation between available threads. 
<OL>
<P>
<LI>After reviewing the source code, compile and run the program. For example:
<P>
<TABLE BORDER=0 CELLPADDING=5>
<TR VALIGN=top>
<TD BGCOLOR=EEEEEE><B>C:</B></TD>
<TD><TT><B>icc -openmp omp_mm.c -o matmult
<BR>matmult </B></TT></TD>
<TR VALIGN=top>
<TD BGCOLOR=EEEEEE><B>Fortran:</B></TD>
<TD><TT><B>ifort -openmp omp_mm.f -o matmult
<BR>matmult</B></TT></TD>
</TR></TABLE>
<P>
<LI>Review the output. It shows which thread did each iteration and the 
    final result matrix. 
<P>
<LI>Run the program again, however this time sort the output to clearly see
which threads execute which iterations:
<P><B><TT>matmult | sort | grep Thread</TT></B>
<P>Do the loop iterations match the SCHEDULE(STATIC,CHUNK) directive for 
   the matrix multiple loop in the code?
</OL>

<P>
<B><LI>Get environment information</B>
<P>
<OL>
<LI>Starting from scratch, write a simple program that obtains information
    about your openMP environment. Alternately, you can modify the "hello"
    program to do this.
<P>
<LI>Using the appropriate openMP routines/functions, have the master thread
    query and print the following:
    <UL>
    <LI>The number of processors available
    <LI>The number of threads being used
    <LI>The maximum number of threads available
    <LI>If you are in a parallel region
    <LI>If dynamic threads are enabled
    <LI>If nested parallelism is supported
    </UL>
<P>
    NOTE: Some compilers (IBM, GNU) implement some of the necessary Fortran 
    functions as integer instead of logical as the standard specifies.
<P>
<LI>If you need help, you can consult the <TT><B>omp_getEnvInfo</B></TT>
    example file.
</OL>

<P>
<B><LI>When things go wrong...</B>
<P>
There are many things that can go wrong when developing OpenMP programs. The
<B><TT>omp_bugX.X</TT></B> series of programs demonstrate just a few.
See if you can figure out what the problem is with each case and then fix it.
<P>
The buggy behavior will differ for each example. Some hints are provided
below.
<P>
<B>Note:</B> Please use the Intel (icc, ifort) compile commands for these
exercises.
<P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=3 WIDTH=90%>
<TR VALIGN=top>
<TH>Code</TH>
<TH>Behavior</TH>
<TH>Hints/Notes</TH>
</TR><TR VALIGN=top>
<TD><TT><B>omp_bug1
<BR>omp_bug1fix</B></TT></TD>
<TD>Fails compilation. Solution provided - must compile solution file.</TD>
<TD><FONT SIZE=-1><INPUT TYPE=button VALUE=Explanation 
onClick=Answers('openMPex01')></FONT></TD>
</TR><TR VALIGN=top> 
<TD><TT><B>omp_bug2</B></TT></TD>
<TD>Thread identifiers are wrong. Wrong answers.</TD>
<TD><FONT SIZE=-1><INPUT TYPE=button VALUE=Explanation  
onClick=Answers('openMPex02')></FONT></TD>
</TR><TR VALIGN=top> 
<TD><TT><B>omp_bug3</B></TT></TD>
<TD>Run-time error, hang.</TD>
<TD><FONT SIZE=-1><INPUT TYPE=button VALUE=Explanation  
onClick=Answers('openMPex03')></FONT></TD>
</TR><TR VALIGN=top> 
<TD><TT><B>omp_bug4
<BR>omp_bug4fix</B></TT></TD>
<TD>Causes a segmentation fault. Solution provided - note that it is a 
script and will need to be "sourced". For example: "source omp_bug4fix". 
Be sure to examine the solution file to see what's going on - especially
the last line, where you may need to change the name of the executable to
match yours.
</TD>
<TD><FONT SIZE=-1><INPUT TYPE=button VALUE=Explanation  
onClick=Answers('openMPex04')></FONT></TD>
</TR><TR VALIGN=top> 
<TD><TT><B>omp_bug5
<BR>omp_bug5fix</B></TT></TD>
<TD>Program hangs. Solution provided - must compile solution file.</TD>
<TD><FONT SIZE=-1><INPUT TYPE=button VALUE=Explanation
onClick=Answers('openMPex05')></FONT></TD>
</TR><TR VALIGN=top> 
<TD><TT><B>omp_bug6</B></TT></TD>
<TD>Failed compilation</TD>
<TD><FONT SIZE=-1><INPUT TYPE=button VALUE=Explanation  
onClick=Answers('openMPex06')></FONT></TD>

</TR></TABLE>

</OL>


<P><HR><P>

<B>This completes the exercise.</B>
<P>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0>
<TR VALIGN=top>
<TD><A HREF=../evaluation/index.html TARGET=evalForm>
    <IMG SRC=../images/evaluationForm.gif 
    BORDER=0 ALT='Evaluation Form'></A> &nbsp; &nbsp; &nbsp;</TD>
<TD>Please complete the online evaluation form if you have not already done
    so for this tutorial. </TD>
</TR>
</TABLE>
<P>
<B>Where would you like to go now?</B>
<UL>
<LI><A HREF=../agenda/index.html>Agenda</A>
<LI><A HREF=index.html>Back to the tutorial</A>
</UL>

<!---------
<UL>
<LI>Return to <A HREF=index.html>OpenMP Tutorial</A>
<LI>Return to <A HREF="javascript://" onClick="resetTop('../index.html');">Workshop Home</A>
</UL>
---------->

<!-------------------------------------------------------------------------->

<SCRIPT LANGUAGE="JavaScript">PrintFooter("UCRL-MI-133316")</SCRIPT>

<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>
<BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR><BR>

</BODY>
</HTML>

